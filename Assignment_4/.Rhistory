1/2*sum(log(R+Y_tilde*1/R*Y_tilde))
}
fit <- optim(c(Sigma1,Sigma2), nll, lower = 0.00001) #indsæt lower bound.
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
-1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll, lower = 0.00001) #indsæt lower bound.
fit
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
-1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll, lower = 0.00000001) #indsæt lower bound.
fit
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
-1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll,method="L-BFGS-B" lower = 0.00000001) #indsæt lower bound.
fit
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
-1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll, method="L-BFGS-B", lower = 0.00000001) #indsæt lower bound.
fit
Y_tilde
Y_tilde
str(Y_tilde)
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll, method="L-BFGS-B", lower = 0.00000001) #indsæt lower bound.
fit
fit <- optim(c(Sigma1,Sigma2), nll, , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit
fit$convergence
x <- c(13, 5, 28, 28, 15, 4, 13, 4, 10, 17, 11, 13, 12, 17, 3)
nll <- function(theta) {
-sum(dnbinom(x, size = theta[1], prob = theta[2], log = TRUE))
}
fit <- optim(c(1, 0.5), nll, lower = 0, upper = c(Inf, 1), hessian = TRUE)
fit$convergence
fit$par
Sal
format long
source("kalman_rem_out.R")
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll, , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
fit
#using C is single index then
kl$Outliers
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
kl$Outliers
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
kl$Outliers
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
kl$Outliers
source("kalman_rem_out.R")
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl$Outliers
sum(kl$Outliers)
fit
Sigma=fit$par
kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kl$Outliers)
Sigma=fit$par
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kl$Outliers)
nll <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
Sigma=fit$par
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kl$Outliers)
#ML estimate
Sigma <- {Sigma1,Sigma2}
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kl$Outliers)
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
(Sigma<-fit$par)
kl<-kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kl$Outliers)
#ML estimate
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
print(kl$Outliers)
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
-1/2*sum(log(R+Y_tilde*1/R*Y_tilde))
1/2*sum(log(R+Y_tilde*1/R*Y_tilde))
nll1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
kl$Outliers
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll1,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
source("kalman.R")
source("kalman_rem_out.R")
#NOW for 1:800
nll2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
(sigma_new <- fit$par)
fit
#NOW for 1:800
nll2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800$pred[interval,1]+sqrt(kl800$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800$pred[interval,1]+sqrt(kl800$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
legend("bottomright",legend=c("Observations","1-step prediciions"),col=c("tomato","seagreen"),pch=c(20,NA),bty='n',lty=c(NA,1))
errors_norm <- na.omit((kl800$pred[interval,1]-Sal[interval]) / sqrt(kl800$Sigma.yy.pred[interval]) )
#MAKE PLOT!!!
plot(interval,errors_norm,ylab="Errors normalized",type='l',xlab="Index")
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800_standard <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800_standard$convergence
(sigma_new <- fit800_standard$par)
nll1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit <- optim(c(Sigma1,Sigma2), nll1,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
(sigma_new <- fit$par)
(sigma_new <- fit800_standard$par)
(sigma_new <- fit2$par)
fit1 <- optim(c(Sigma1,Sigma2), nll1,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
(sigma_new <- fit1$par)
fit1$par
fit2$par
fit1$par
fit2$par
fit800$par
fit800_standard$par
source("kalman.R")
source("kalman_rem_out.R")
nll1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit1 <- optim(c(Sigma1,Sigma2), nll1,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
(sigma_new <- fit1$par)
fit1
new_kl1 <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
nll2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit2 <- optim(c(Sigma1,Sigma2), nll2,method="L-BFGS-B" , lower = 0.00005) #indsæt lower bound. #method="L-BFGS-B"
fit2$convergence
(sigma_new <- fit2$par)
fit
new_k2l <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(new_k2l$Outliers) #Outliers
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800$pred[interval,1]+sqrt(kl800$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
legend("bottomright",legend=c("Observations","1-step prediciions"),col=c("tomato","seagreen"),pch=c(20,NA),bty='n',lty=c(NA,1))
errors_norm <- na.omit((kl800$pred[interval,1]-Sal[interval]) / sqrt(kl800$Sigma.yy.pred[interval]) )
#MAKE PLOT!!!
plot(interval,errors_norm,ylab="Errors normalized",type='l',xlab="Index")
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800_standard <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = 0.00000005) #indsæt lower bound. #method="L-BFGS-B"
fit800_standard$convergence
(sigma_new <- fit800_standard$par)
fit
kl800_standard <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800_standard$pred[interval,1]+sqrt(kl800_standard$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
legend("bottomright",legend=c("Observations","1-step prediciions"),col=c("tomato","seagreen"),pch=c(20,NA),bty='n',lty=c(NA,1))
errors_norm <- na.omit((kl800_standard$pred[interval,1]-Sal[interval]) / sqrt(kl800_standard$Sigma.yy.pred[interval]) )
#MAKE PLOT!!!
plot(interval,errors_norm,ylab="Errors normalized",type='l',xlab="Index")
fit1$par
fit2$par
fit800$par
fit800_standard$par
LowerBound <- 0.000000000000001
source("~/Documents/5. DTU noter/Semester 6/02417_Time_Series_Analysis/Time_Series_2023/Assignment_4/Ass4_4.5.r", echo=TRUE)
source("~/Documents/5. DTU noter/Semester 6/02417_Time_Series_Analysis/Time_Series_2023/Assignment_4/Ass4_4.5.r", echo=TRUE)
kltest <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kltest$outliers
kltest$Outliers
sum(kltest$Outliers)
kltest <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kltest$Outliers)
kltest <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kltest$Outliers)
kltest <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kltest$Outliers)
fit1$par
fit2$par
fit800$par
fit800_standard$par
kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl1test <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl2test <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl2test$Outliers
sum(kl2test$Outliers)
kl1test <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl2test <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
nlltest1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit_test1 <- optim(c(Sigma1,Sigma2), nlltest1,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit_test1$convergence
fit_test1$par
fit
nlltest2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit_test1 <- optim(c(Sigma1,Sigma2), nlltest2,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit_test2$convergence
fit_test1$par
fit_test2$par
nlltest1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit_test1 <- optim(c(Sigma1,Sigma2), nlltest1,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit_test1$convergence
fit_test1$par
fit
nlltest2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit_test2 <- optim(c(Sigma1,Sigma2), nlltest2,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit_test2$convergence
fit_test1$convergence
fit_test1$par
fit_test2$par
kl1 <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
kl2 <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
str(kl1)
str(kl2)
kl1==kl2
kl1$rec==kl2$rec
sum(!kl1$rec==kl2$rec)
sum(na.omit(!kl1$rec==kl2$rec))
sum(na.omit(!kl1$pred==kl2$pred))
fit1$par
fit2$par
fit800$par
fit800_standard$par
LowerBound <- 0.0005^2
nll1 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
#using C is single index then
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit1 <- optim(c(Sigma1,Sigma2), nll1,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit$convergence
(sigma_new <- fit1$par)
fit1
new_kl1 <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
nll2 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal)
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit2 <- optim(c(Sigma1,Sigma2), nll2,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit2$convergence
(sigma_new <- fit2$par)
fit
kltest <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kltest$Outliers)
kltest <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(kltest$Outliers)
new_k2l <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
sum(new_k2l$Outliers) #Outliers
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman_rem_out(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800 <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit800$convergence
(sigma_new <- fit800$par)
fit
kl800 <- kalman_rem_out(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800$pred[interval,1]+sqrt(kl800$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
legend("bottomright",legend=c("Observations","1-step prediciions"),col=c("tomato","seagreen"),pch=c(20,NA),bty='n',lty=c(NA,1))
errors_norm <- na.omit((kl800$pred[interval,1]-Sal[interval]) / sqrt(kl800$Sigma.yy.pred[interval]) )
#MAKE PLOT!!!
plot(interval,errors_norm,ylab="Errors normalized",type='l',xlab="Index")
#NOW for 1:800
nll800 <- function(Sigma){ #Sigma[1] og Sigma[2].  Sigma <- array(c(Sigma1,Sigma2),dim=c(1,1,2))
kl <- kalman(Sal[1:800],A=A,B=B,u=NULL,C=C,Sigma.1=matrix(Sigma[1]),Sigma.2=matrix(Sigma[2]),debug=FALSE,V0=matrix(Sigma[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
N <- length(Sal[1:800])
R <- na.omit( (c(C)*kl$Sigma.xx.pred[1,1,]*c(C)+c(matrix(Sigma[2])))[1:N]+0*(Sal[1:N]-kl$pred[1:N]) )
Y_tilde <- na.omit(Sal[1:N]-kl$pred[1:N])
1/2*sum(log(R)+Y_tilde*1/R*Y_tilde)
}
fit800_standard <- optim(c(Sigma1,Sigma2), nll800,method="L-BFGS-B" , lower = LowerBound) #indsæt lower bound. #method="L-BFGS-B"
fit800_standard$convergence
(sigma_new <- fit800_standard$par)
fit
kl800_standard <- kalman(Sal,A=A,B=B,u=NULL,C=C,Sigma.1=matrix(sigma_new[1]),Sigma.2=matrix(sigma_new[2]),debug=FALSE,V0=matrix(sigma_new[1]),Xhat0=Sal[1],n.ahead=1,skip=0,verbose=TRUE)
interval = c(800:950)
#3. Plot for 800-950
plot(interval,Sal[interval],type="p",,col="red",xlab="Index",ylab="Water Salinity [PSU] = [g/kg]",ylim=c(15,24))
matlines(interval,kl800_standard$pred[interval,1]+sqrt(kl800_standard$Sigma.yy.pred[1,1,interval])%*%cbind(0,-1.96,1.96),col="seagreen",lty=c(1,2,2), lwd=1)
legend("bottomright",legend=c("Observations","1-step prediciions"),col=c("tomato","seagreen"),pch=c(20,NA),bty='n',lty=c(NA,1))
errors_norm <- na.omit((kl800_standard$pred[interval,1]-Sal[interval]) / sqrt(kl800_standard$Sigma.yy.pred[interval]) )
#MAKE PLOT!!!
plot(interval,errors_norm,ylab="Errors normalized",type='l',xlab="Index")
fit1$par
fit2$par
fit800$par
fit800_standard$par
